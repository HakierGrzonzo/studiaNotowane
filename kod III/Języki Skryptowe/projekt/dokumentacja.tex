% !TEX program = xelatex
\documentclass[12pt,a4paper]{article}
%\usepackage[T1]{fontenc}
\usepackage{inputenc}[utf8]

\usepackage{hyperref}
\usepackage{url}

\usepackage{color}

\usepackage{polski}
\usepackage[polish]{babel} 
\usepackage{indentfirst}
\usepackage{icomma}
\usepackage{algorithm2e}

\brokenpenalty=1000
\clubpenalty=1000
\widowpenalty=1000    

%nie odkometowuj wszystkiego, użyj mózgu
%\renewcommand\thechapter{\arabic{chapter}.}
\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\arabic{section}.\arabic{subsection}.}
\renewcommand\thesubsubsection{\arabic{subsubsection}.}
\definecolor{red}{rgb}{0.6,0,0} % for strings
\definecolor{blue}{rgb}{0,0,0.6}
\definecolor{green}{rgb}{0,0.8,0}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}


\addtolength{\hoffset}{-1.5cm}
\addtolength{\marginparwidth}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textheight}{2.5cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}

\begin{document}
	
	\title{Języki Skryptowe\\\small{dokumentacja projektu ,,Hotele''}}
	\author{Grzegorz Koperwas}
	\date{\today}

	\maketitle
	\newpage
	\section*{Część I}
	\subsection*{Opis programu}

    W Bajtocji jest n miast połączonych zaledwie n − 1 drogami. Każda z dróg łączy bezpośrednio dwa miasta.
    Wszystkie drogi mają taką samą długość i są dwukierunkowe. Wiadomo, że z każdego miasta da się dojechać
    do każdego innego dokładnie jedną trasą, złożoną z jednej lub większej liczby dróg. Inaczej mówiąc, sieć dróg
    tworzy drzewo.

    Król Bajtocji, Bajtazar, chce wybudować trzy luksusowe hotele, które będą gościć turystów z całego świata.

    Król chciałby, aby hotele znajdowały się w różnych miastach i były położone w tych samych odległościach od
    siebie.

    Pomóż królowi i napisz program, który obliczy, na ile sposobów można wybudować takie trzy hotele w Baj-
    tocji.

	\subsection*{Instrukcja obsługi}

    Należy wykonać plik \texttt{./run.sh}, wygeneruje on automatycznie zestawy
    danych testowych, wykona plik \texttt{./projekt.py} dla nich, oraz
    wygeneruje skryptem \texttt{./raport.py} plik \texttt{./raport.html}.

	\subsection*{Dodatkowe informacje}

    Wymagania:

    \begin{enumerate}
            \item Biblioteka Jinja2
            \item Python3 (sprawdzanie działanie na wersji 3.9.7, wcześniejsze mogą nie
                działać)
    \end{enumerate}

	\newpage
	\section*{Część II}
	\subsection*{Opis działania} 
	
    Dane jest drzewo $n$ węzłów.

    W pierwszej fazie, dla każdego węzła jest twożony jest słownik zwracający
    dystans do dannego węzła (miasta), dla dannego węzła\footnote{W dalszej
    części pracy będe stosował te wyrażenia wymiennie}.

    W drugiej fazie, dla każdego miasta, twożony jest słownik zwracający listę
    wszystkich miast, których odległość jest równa, dla danej odległości.

    Następnie, dla każdej odległości\footnote{kluczy słownika}, jest zliczana
    liczba miast spełniających warunek zadania\footnote{W wynniku optymalizacji
    powtóżenia są eliminowane}.
	
	\subsection*{Algorytmy}
    
    \subsubsection*{Generacja słownika Miasto $\rightarrow$ odległość}

	Zrealizowany jest głównie w metodzie \texttt{get\_connections} w klasie \texttt{Miasto}.

	Każde ,,Miasto'' jest węzłem w drzewie, zawiera ono domyślnie pusty słownik \texttt{city2distace}\footnote{Zwany równierz słownikiem Miasto $\rightarrow$ odległość}, flagę trybu szybkiego, puste polę na bramę trybu szybkiego oraz listę połączeń z innymi miastami.

	\textbf{Tryb szybki} jest uruchamiany jeżeli napotkamy na sytuację, gdzie występuje \emph{dokładnie jeden} węzeł łączący dane miasto (brama) z resztą drzewa. Wtedy zamiast ,,chodzić'' po drzewie, możemy przepisać słownik z \emph{bramy trybu szybkiego}.
    
	\begin{algorithm}[h]
		\SetKwFunction{Fcon}{GetConnections}
		\SetKwProg{Fn}{funkcja}{:}{}
		\Fn{\Fcon{$miasto$, $force\_slow$}}{
			\If{miasto jest w trybie szybkim i nie ma ustawionej flagi force\_slow}{
				\tcc{W trybie szybkim dopisujemy nowe miasta z ,,bramy''}
				\For{miasto w city2distace w bramie}{
					\If{miasto nie jest w city2distace}{
						city2distace[ miasto ] = dystans do bramy + dystans z bramy do miasta
					}
				}
			}
			\ElseIf{dict city2distance jest pusty}{
				\For{połączenie w miasto}{
					city2distace[ miasto z połączenia ] = 1
				}
				\tcc{Sprawdź czy możemy wejść w tryb szybki}
				\If{miasto ma jednego sąsiada}{
					wejdź w tryb szybki i ustaw bramę na znalezione miasto
				}
			}
			\Else{
				tmp = dict()\;
				\For{miasto w city2distace}{
					\If{miasto jest najbardziej oddalonym miastem}{
						\For{dla sąsiadów miasta}{
							\If{sąsiad nie jest w city2distace}{
								tmp[ sąsiad ] = dystans do miasta + 1
							}
						}
					}
				}
				\If{w tmp jest tylko jedno miasto}{
					wejdź w tryb szybki
				}
				dopisz elementy z tmp do city2distance
			}
			\Return{czy jestem w trybie szybkim}
		}
		\caption{Metoda pomocnicza do obliczania dystansu}
	\end{algorithm}
	\begin{algorithm}[h]
		\SetKwFunction{Fmain}{main}
		\SetKwProg{Fn}{funkcja}{:}{}
		\Fn{\Fmain{$miasta$}}{
			skończoneMiasta = []
			\While{len(skończoneMiasta) != len(miasta)}{
				\For{miasto w miasta}{
					\If{miasto w skończoneMiasta}{
						continue
					}
					\ElseIf{miasto ma odległość do wszystkich innych miast}{
						dodaj miasto do skończoneMiasta
					}
					\Else{
						GetConnections(miasto)
						\If{miasto jest w trybie szybkim}{
							dodaj miasto do skończoneMiasta
						}
					}
				}
			}
			fin = []
			\tcc{Dokończ miasta w trybie szybkim}
			\While{len(fin) != len(skończoneMiasta)}{
				\For{miasto w skończoneMiasta}{
					\If{miasto w fin}{
						continue
					}
					\ElseIf{Miasto ma odległość do wszystkich innych miast}{
						dodaj miasto do fin
					}
					\Else{
						GetConnections(miasto)
					}
				}
				\If{nie było zmian w fin}{
					\tcc{wymuś tryb powolny w miastach}
					\For{miasto w skończoneMiasta}{
						\If{miasto w fin}{
							continue
						}
						\Else{
							GetConnections(miasto, true)
						}
					}
				}
			}
			\Return{fin}
		}
		\caption{Obliczanie dystansu dla wszystkich miast}
	\end{algorithm}

	\subsubsection*{Algorytm wyznaczania ilości hoteli.}
	
	Każde miasto posiada unikalne id. Zatem w celu wyeliminowania powtórzeń tych samych konfiguracji hoteli, każde miasto wyznacza możliwe konfiguracje hoteli, gdzie jego ,,partnerzy'' posiadają większe id.

	\begin{algorithm}[h]
		\KwIn{miasto}
		\KwOut{res}
		distance2city = \{\} \tcc{odwrócenie słownika city2distace}
		\For{miasto w city2distace}{
			\If{id miasta > id miasta rozważanego}{
				dodaj miasto do distance2city
			}
		}
		\For{miasta w distance2city}{
			\If{conajmniej 2 miasta dla danego dystansu}{
				\For{miasto poza pierwszym dla danego dystansu}{
					\For{miasta po rozważanym miastem}{
						\If{Dystans między miastami jest równy}{
							dodaj hotele do res
						}
					}
				}
			}
		}
		\caption{Wyznaczanie ilości hoteli w jednym mieście}
	\end{algorithm}

	\subsection*{Implementacja}
	Opis, zasada i działanie programu ze względu na podział na pliki, nastepnie	funkcje programu wraz ze szczegółowym opisem działania (np.: formie pseudokodu, czy odniesienia do równania)
	\subsection*{Testy}
	Tutaj powinna pojawić się analiza uzyskanych wyników oraz wykresy/pomiary.
	
	\subsection*{Eksperymenty}
	Sekcję używamy gdy porównywaliśmy dwa lub więcej algorytmów, albo wykonywaliśmy jakies pomiery.
	
	Warto dodać jakies wykresy jako obraz, albo tabele z wynikami. 
	
	Wszyskie wyniki powinny być opisane/poddane komentarzowi i poddane analizie statystycznej.
	\newpage
	\section*{Pełen kod aplikacji}
\end{document}
