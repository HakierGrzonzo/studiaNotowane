% !TEX program = xelatex
\documentclass[12pt,a4paper]{article}
%\usepackage[T1]{fontenc}
\usepackage{inputenc}[utf8]

\usepackage{hyperref}
\usepackage{listings}
\usepackage{url}

\usepackage{color}

\usepackage{polski}
\usepackage[polish]{babel} 
\usepackage{indentfirst}
\usepackage{icomma}
\usepackage{algorithm2e}

\brokenpenalty=1000
\clubpenalty=1000
\widowpenalty=1000    

%nie odkometowuj wszystkiego, użyj mózgu
%\renewcommand\thechapter{\arabic{chapter}.}
\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\arabic{section}.\arabic{subsection}.}
\renewcommand\thesubsubsection{\arabic{subsubsection}.}
\definecolor{red}{rgb}{0.6,0,0} % for strings
\definecolor{blue}{rgb}{0,0,0.6}
\definecolor{green}{rgb}{0,0.8,0}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}


\addtolength{\hoffset}{-1.5cm}
\addtolength{\marginparwidth}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textheight}{2.5cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}

\begin{document}
	
	\title{Języki Skryptowe\\\small{dokumentacja projektu ,,Hotele''}}
	\author{Grzegorz Koperwas}
	\date{\today}

	\maketitle
	\newpage
	\section*{Część I}
	\subsection*{Opis programu}

    W Bajtocji jest $n$ miast połączonych zaledwie $n - 1$ drogami. Każda z dróg łączy bezpośrednio dwa miasta.
    Wszystkie drogi mają taką samą długość i są dwukierunkowe. Wiadomo, że z każdego miasta da się dojechać
    do każdego innego dokładnie jedną trasą, złożoną z jednej lub większej liczby dróg. Inaczej mówiąc, sieć dróg
    tworzy drzewo.

    Król Bajtocji, Bajtazar, chce wybudować trzy luksusowe hotele, które będą gościć turystów z całego świata.

    Król chciałby, aby hotele znajdowały się w różnych miastach i były położone w tych samych odległościach od
    siebie.

    Pomóż królowi i napisz program, który obliczy, na ile sposobów można
    wybudować takie trzy hotele w Bajtocji.

	\subsection*{Instrukcja obsługi}

    Należy wykonać plik \texttt{./run.sh}, wygeneruje on automatycznie zestawy
    danych testowych, wykona plik \texttt{./projekt.py} dla nich, oraz
    wygeneruje skryptem \texttt{./raport.py} plik \texttt{./raport.html}.

    Skrypt \texttt{./backup.sh} tworzy kopię plików wejściowych, wyjściowych
    oraz raportu i zapisuje je w archiwum \texttt{\$\{data\}.tar.gz}.


	\subsection*{Dodatkowe informacje}

    Wymagania:

    \begin{enumerate}
            \item Biblioteka Jinja2
            \item Python3 (gwarantowane działanie na wersji 3.9.7, wcześniejsze mogą nie
                działać)
            \item System zgodny z POSIX
    \end{enumerate}

	\newpage
	\section*{Część II}
	\subsection*{Opis działania} 
	
    Dane jest drzewo $n$ węzłów.

    W pierwszej fazie, dla każdego węzła jest twożony jest słownik zwracający
    dystans do dannego węzła (miasta), dla dannego węzła\footnote{W dalszej
    części pracy będe stosował te wyrażenia wymiennie}.

    W drugiej fazie, dla każdego miasta, twożony jest słownik zwracający listę
    wszystkich miast, których odległość jest równa, dla danej odległości.

    Następnie, dla każdej odległości\footnote{kluczy słownika}, jest zliczana
    liczba miast spełniających warunek zadania\footnote{W wynniku optymalizacji
    powtóżenia są eliminowane}.
	
	\subsection*{Algorytmy}
    
    \subsubsection*{Generacja słownika Miasto $\rightarrow$ odległość}

	Zrealizowany jest głównie w metodzie \texttt{get\_connections} w klasie \texttt{Miasto}.

	Każde ,,Miasto'' jest węzłem w drzewie, zawiera ono domyślnie pusty słownik \texttt{city2distace}\footnote{Zwany równierz słownikiem Miasto $\rightarrow$ odległość}, flagę trybu szybkiego, puste polę na bramę trybu szybkiego oraz listę połączeń z innymi miastami.

	\textbf{Tryb szybki} jest uruchamiany jeżeli napotkamy na sytuację, gdzie występuje \emph{dokładnie jeden} węzeł łączący dane miasto (brama) z resztą drzewa. Wtedy zamiast ,,chodzić'' po drzewie, możemy przepisać słownik z \emph{bramy trybu szybkiego}.
    
	\begin{algorithm}[H]
		\SetKwFunction{Fcon}{GetConnections}
		\SetKwProg{Fn}{funkcja}{:}{}
		\Fn{\Fcon{$miasto$, $force\_slow$}}{
			\If{miasto jest w trybie szybkim i nie ma ustawionej flagi force\_slow}{
				\tcc{W trybie szybkim dopisujemy nowe miasta z ,,bramy''}
				\For{miasto w city2distace w bramie}{
					\If{miasto nie jest w city2distace}{
						city2distace[ miasto ] = dystans do bramy + dystans z bramy do miasta
					}
				}
			}
			\ElseIf{dict city2distance jest pusty}{
				\For{połączenie w miasto}{
					city2distace[ miasto z połączenia ] = 1
				}
				\tcc{Sprawdź czy możemy wejść w tryb szybki}
				\If{miasto ma jednego sąsiada}{
					wejdź w tryb szybki i ustaw bramę na znalezione miasto
				}
			}
			\Else{
				tmp = dict()\;
				\For{miasto w city2distace}{
					\If{miasto jest najbardziej oddalonym miastem}{
						\For{dla sąsiadów miasta}{
							\If{sąsiad nie jest w city2distace}{
								tmp[ sąsiad ] = dystans do miasta + 1
							}
						}
					}
				}
				\If{w tmp jest tylko jedno miasto}{
					wejdź w tryb szybki
				}
				dopisz elementy z tmp do city2distance
			}
			\Return{czy jestem w trybie szybkim}
		}
		\caption{Metoda pomocnicza do obliczania dystansu}
	\end{algorithm}
	\begin{algorithm}[H]
		\SetKwFunction{Fmain}{main}
		\SetKwProg{Fn}{funkcja}{:}{}
		\Fn{\Fmain{$miasta$}}{
			skończoneMiasta = []
			\While{len(skończoneMiasta) != len(miasta)}{
				\For{miasto w miasta}{
					\If{miasto w skończoneMiasta}{
						continue
					}
					\ElseIf{miasto ma odległość do wszystkich innych miast}{
						dodaj miasto do skończoneMiasta
					}
					\Else{
						GetConnections(miasto)
						\If{miasto jest w trybie szybkim}{
							dodaj miasto do skończoneMiasta
						}
					}
				}
			}
			fin = []
			\tcc{Dokończ miasta w trybie szybkim}
			\While{len(fin) != len(skończoneMiasta)}{
				\For{miasto w skończoneMiasta}{
					\If{miasto w fin}{
						continue
					}
					\ElseIf{Miasto ma odległość do wszystkich innych miast}{
						dodaj miasto do fin
					}
					\Else{
						GetConnections(miasto)
					}
				}
				\If{nie było zmian w fin}{
					\tcc{wymuś tryb powolny w miastach}
					\For{miasto w skończoneMiasta}{
						\If{miasto w fin}{
							continue
						}
						\Else{
							GetConnections(miasto, true)
						}
					}
				}
			}
			\Return{fin}
		}
		\caption{Obliczanie dystansu dla wszystkich miast}
	\end{algorithm}

	\subsubsection*{Algorytm wyznaczania ilości hoteli.}
	
	Każde miasto posiada unikalne id. Zatem w celu wyeliminowania powtórzeń tych samych konfiguracji hoteli, każde miasto wyznacza możliwe konfiguracje hoteli, gdzie jego ,,partnerzy'' posiadają większe id.

	\begin{algorithm}[H]
		\KwIn{miasto}
		\KwOut{res}
		distance2city = \{\} \tcc{odwrócenie słownika city2distace}
		\For{miasto w city2distace}{
			\If{id miasta > id miasta rozważanego}{
				dodaj miasto do distance2city
			}
		}
		\For{miasta w distance2city}{
			\If{conajmniej 2 miasta dla danego dystansu}{
				\For{miasto poza pierwszym dla danego dystansu}{
					\For{miasta po rozważanym miastem}{
						\If{Dystans między miastami jest równy}{
							dodaj hotele do res
						}
					}
				}
			}
		}
		\caption{Wyznaczanie ilości hoteli w jednym mieście}
	\end{algorithm}

	\subsection*{Implementacja}

    Projekt posiada tradycyjną strukturę w formie jednej klasy na plik, plus 
    plik spinający całość. Projekt nie posiada struktury modułu.

    \begin{itemize}
        \item Plik \texttt{projekt.py} zawiera główną część projektu.
        
        \item Plik \texttt{miasto.py} zawiera definicje klasy Miasto.

        \item Plik \texttt{connection.py} zawiera definicje klasy Connection.

        \item Plik \texttt{generate.py} zawiera prosty skrypt generujący
            przypadki
    \end{itemize}

	\subsection*{Testy}

    Zgodność wyników była sprawdzana na manualnie określonych przypadkach.
    Dodatkowo w celu testów na większych problemach powstał skrypt
    \texttt{generate.py}.

    Dodatkowo dla celów testowych była wprowadzona funkcjonalność eksportu
    zparsowanych drzew do aplikacji graphviz, która radziła sobie z eksportem
    drzew z tysiącami miast bez żadnych problemów.
	
	\subsection*{Eksperymenty}

    W trakcie tworzenia projektu najwięcej czasu spędziłem nad optymalizacją
    rozwiązania. Próbowane były algorytmy wieloprocesorowe\footnote{Wielowątkowość
    w języku \texttt{python} nie daje wzrostu wydajności ze względu na
    \emph{Global Interpreter Lock}, tzw. GIL. Problem w zadaniu nie jest
    ograniczany przez I/O, zatem wielowątkowość w tradycyjnym tego słowa
    znaczeniu nie ma sensu}. Jednak ostatecznie rozwiązanie
    oparte na porównywaniu \texttt{id} miast pozwoliło łatwo rozwiązać problem
    powtarzających się trójek hoteli jak i zmniejszyło znacząco czas
    wykonywania się programu dla większych drzew, jak i znacząco zmniejszyło
    ilość pamięci potrzebnej do zapisywania wyników (z około 700mb dla
    rozwiązania trzymającego wszystkie hotele w liście do pomijalnego dla
    obiektu \texttt{int}). 

    Dodatkowo problem wyznaczania słownika miasta do dystansu został
    przyspieszony przez wprowadzenie \emph{trybu szybkiego}, który potrafi
    odrzucić połowę miast w pierwszej iteracji.


    \newpage
	\section*{Pełen kod aplikacji}

\lstinputlisting[language=python,frame=L,basicstyle=\ttfamily\footnotesize,numbers=left,caption=projekt.py]{./projekt.py}
\lstinputlisting[language=python,frame=L,basicstyle=\ttfamily\footnotesize,numbers=left,caption=miasto.py]{./miasto.py}
\lstinputlisting[language=python,frame=L,basicstyle=\ttfamily\footnotesize,numbers=left,caption=connection.py]{./connection.py}
\end{document}
